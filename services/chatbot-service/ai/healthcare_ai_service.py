import openai
import logging
from typing import List, Dict, Any, Optional
from django.conf import settings
from knowledge.models import ChatbotResponse
from knowledge.services import KnowledgeSearchEngine, SymptomChecker

logger = logging.getLogger(__name__)


class HealthcareAIService:
    """Service t√≠ch h·ª£p AI cho healthcare chatbot"""
    
    def __init__(self):
        self.search_engine = KnowledgeSearchEngine()
        self.symptom_checker = SymptomChecker()
        
        # Initialize OpenAI
        if hasattr(settings, 'OPENAI_API_KEY'):
            openai.api_key = settings.OPENAI_API_KEY
        else:
            logger.warning("OpenAI API key not configured")
    
    def generate_response(self, user_query: str, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Generate AI response based on user query and knowledge base"""
        try:
            # Analyze query intent
            intent = self._analyze_intent(user_query)
            
            # Search knowledge base
            knowledge_results = self.search_engine.search_knowledge(user_query, limit=5)
            
            # Generate contextual response
            if intent['type'] == 'symptom_check':
                response = self._handle_symptom_check(user_query, intent, context)
            elif intent['type'] == 'disease_info':
                response = self._handle_disease_info(user_query, knowledge_results)
            elif intent['type'] == 'emergency':
                response = self._handle_emergency(user_query)
            elif intent['type'] == 'appointment':
                response = self._handle_appointment(user_query, context)
            else:
                response = self._handle_general_query(user_query, knowledge_results)
            
            # Save response for learning
            self._save_response(user_query, response, intent['type'])
            
            return response
            
        except Exception as e:
            logger.error(f"Error generating AI response: {str(e)}")
            return {
                'response': 'Xin l·ªói, t√¥i ƒëang g·∫∑p s·ª± c·ªë k·ªπ thu·∫≠t. Vui l√≤ng th·ª≠ l·∫°i sau.',
                'type': 'error',
                'confidence': 0.0
            }
    
    def _analyze_intent(self, query: str) -> Dict[str, Any]:
        """Analyze user intent from query"""
        query_lower = query.lower()
        
        # Symptom checking keywords
        symptom_keywords = [
            'tri·ªáu ch·ª©ng', 'ƒëau', 'nh·ª©c', 's·ªët', 'ho', 'kh√≥ th·ªü', 'ch√≥ng m·∫∑t',
            'bu·ªìn n√¥n', 'm·ªát m·ªèi', 'ƒëau ƒë·∫ßu', 'ƒëau b·ª•ng', 'ƒëau ng·ª±c'
        ]
        
        # Emergency keywords
        emergency_keywords = [
            'c·∫•p c·ª©u', 'nguy hi·ªÉm', 'nghi√™m tr·ªçng', 'kh·∫©n c·∫•p', 'g·∫•p',
            'ƒëau d·ªØ d·ªôi', 'kh√≥ th·ªü n·∫∑ng', 'ng·∫•t x·ªâu', 'co gi·∫≠t'
        ]
        
        # Disease information keywords
        disease_keywords = [
            'b·ªánh', 'ch·∫©n ƒëo√°n', 'nguy√™n nh√¢n', 'ƒëi·ªÅu tr·ªã', 'thu·ªëc',
            'ph√≤ng ng·ª´a', 'bi·∫øn ch·ª©ng', 'ti√™n l∆∞·ª£ng'
        ]
        
        # Appointment keywords
        appointment_keywords = [
            'ƒë·∫∑t l·ªãch', 'h·∫πn kh√°m', 'booking', 'appointment', 'l·ªãch h·∫πn',
            'kh√°m b·ªánh', 't∆∞ v·∫•n', 'g·∫∑p b√°c sƒ©'
        ]
        
        # Check intent
        if any(keyword in query_lower for keyword in emergency_keywords):
            return {'type': 'emergency', 'confidence': 0.9}
        elif any(keyword in query_lower for keyword in symptom_keywords):
            return {'type': 'symptom_check', 'confidence': 0.8}
        elif any(keyword in query_lower for keyword in disease_keywords):
            return {'type': 'disease_info', 'confidence': 0.7}
        elif any(keyword in query_lower for keyword in appointment_keywords):
            return {'type': 'appointment', 'confidence': 0.8}
        else:
            return {'type': 'general', 'confidence': 0.5}
    
    def _handle_symptom_check(self, query: str, intent: Dict, context: Dict) -> Dict[str, Any]:
        """Handle symptom checking queries"""
        try:
            # Extract symptoms from query
            symptoms = self._extract_symptoms(query)
            
            if not symptoms:
                return {
                    'response': 'T√¥i hi·ªÉu b·∫°n mu·ªën ki·ªÉm tra tri·ªáu ch·ª©ng. B·∫°n c√≥ th·ªÉ m√¥ t·∫£ c·ª• th·ªÉ h∆°n v·ªÅ tri·ªáu ch·ª©ng ƒëang g·∫∑p ph·∫£i kh√¥ng?',
                    'type': 'symptom_check',
                    'confidence': 0.6,
                    'follow_up': True
                }
            
            # Use symptom checker
            result = self.symptom_checker.check_symptoms(symptoms, context)
            
            # Format response
            response_text = self._format_symptom_response(result)
            
            return {
                'response': response_text,
                'type': 'symptom_check',
                'confidence': 0.8,
                'data': result,
                'disclaimer': result.get('disclaimer')
            }
            
        except Exception as e:
            logger.error(f"Error in symptom checking: {str(e)}")
            return {
                'response': 'Xin l·ªói, t√¥i kh√¥ng th·ªÉ ki·ªÉm tra tri·ªáu ch·ª©ng l√∫c n√†y. Vui l√≤ng li√™n h·ªá b√°c sƒ© n·∫øu tri·ªáu ch·ª©ng nghi√™m tr·ªçng.',
                'type': 'error',
                'confidence': 0.0
            }
    
    def _handle_disease_info(self, query: str, knowledge_results: List[Dict]) -> Dict[str, Any]:
        """Handle disease information queries"""
        if not knowledge_results:
            return {
                'response': 'T√¥i kh√¥ng t√¨m th·∫•y th√¥ng tin v·ªÅ v·∫•n ƒë·ªÅ b·∫°n h·ªèi. B·∫°n c√≥ th·ªÉ di·ªÖn ƒë·∫°t l·∫°i c√¢u h·ªèi kh√¥ng?',
                'type': 'disease_info',
                'confidence': 0.3
            }
        
        # Get best match
        best_result = knowledge_results[0]
        entry = best_result['entry']
        
        # Format response based on entry type
        if entry.content_type == 'FAQ':
            response_text = f"**{entry.title}**\\n\\n{entry.content}"
        else:
            response_text = f"**{entry.title}**\\n\\n{entry.summary or entry.content[:500]}..."
        
        # Add related information
        if len(knowledge_results) > 1:
            response_text += "\\n\\n**Th√¥ng tin li√™n quan:**\\n"
            for result in knowledge_results[1:3]:
                response_text += f"- {result['entry'].title}\\n"
        
        return {
            'response': response_text,
            'type': 'disease_info',
            'confidence': best_result['score'],
            'source': {
                'title': entry.title,
                'author': entry.author,
                'reliability': entry.reliability_score
            }
        }
    
    def _handle_emergency(self, query: str) -> Dict[str, Any]:
        """Handle emergency queries"""
        emergency_response = """
üö® **T√åNH HU·ªêNG C·∫§P C·ª®U**

**G·ªçi ngay 115 ho·∫∑c ƒë·∫øn c∆° s·ªü y t·∫ø g·∫ßn nh·∫•t!**

**M·ªôt s·ªë x·ª≠ l√Ω c·∫•p c·ª©u c∆° b·∫£n:**

1. **Gi·ªØ b√¨nh tƒ©nh** v√† ƒë√°nh gi√° t√¨nh h√¨nh
2. **ƒê·∫£m b·∫£o an to√†n** cho b·ªánh nh√¢n v√† ng∆∞·ªùi xung quanh
3. **Ki·ªÉm tra tri gi√°c, h√¥ h·∫•p, m·∫°ch** c·ªßa b·ªánh nh√¢n
4. **Kh√¥ng di chuy·ªÉn** b·ªánh nh√¢n n·∫øu nghi ng·ªù ch·∫•n th∆∞∆°ng c·ªôt s·ªëng
5. **Chu·∫©n b·ªã th√¥ng tin** cho ƒë·ªôi c·∫•p c·ª©u

**L∆∞u √Ω quan tr·ªçng:** Th√¥ng tin n√†y ch·ªâ mang t√≠nh tham kh·∫£o. Trong t√¨nh hu·ªëng c·∫•p c·ª©u, lu√¥n ∆∞u ti√™n g·ªçi 115 v√† ƒë·∫øn c∆° s·ªü y t·∫ø.
        """
        
        return {
            'response': emergency_response.strip(),
            'type': 'emergency',
            'confidence': 0.95,
            'urgent': True,
            'actions': ['call_115', 'go_to_hospital']
        }
    
    def _handle_appointment(self, query: str, context: Dict) -> Dict[str, Any]:
        """Handle appointment booking queries"""
        return {
            'response': 'T√¥i c√≥ th·ªÉ gi√∫p b·∫°n ƒë·∫∑t l·ªãch h·∫πn kh√°m. B·∫°n mu·ªën ƒë·∫∑t l·ªãch v·ªõi chuy√™n khoa n√†o v√† v√†o th·ªùi gian n√†o?',
            'type': 'appointment',
            'confidence': 0.8,
            'actions': ['show_appointment_form', 'list_doctors'],
            'next_step': 'appointment_booking'
        }
    
    def _handle_general_query(self, query: str, knowledge_results: List[Dict]) -> Dict[str, Any]:
        """Handle general healthcare queries"""
        if not knowledge_results:
            return {
                'response': 'T√¥i hi·ªÉu b·∫°n ƒëang c·∫ßn th√¥ng tin v·ªÅ s·ª©c kh·ªèe. B·∫°n c√≥ th·ªÉ h·ªèi c·ª• th·ªÉ h∆°n v·ªÅ tri·ªáu ch·ª©ng, b·ªánh l√Ω, ho·∫∑c v·∫•n ƒë·ªÅ s·ª©c kh·ªèe n√†o ƒë√≥ kh√¥ng?',
                'type': 'general',
                'confidence': 0.4,
                'suggestions': [
                    'Ki·ªÉm tra tri·ªáu ch·ª©ng',
                    'Th√¥ng tin v·ªÅ b·ªánh l√Ω',
                    'ƒê·∫∑t l·ªãch kh√°m',
                    'T∆∞ v·∫•n s·ª©c kh·ªèe'
                ]
            }
        
        # Combine information from multiple sources
        response_parts = []
        confidence_scores = []
        
        for result in knowledge_results[:3]:
            entry = result['entry']
            response_parts.append(f"**{entry.title}**\\n{entry.summary or entry.content[:300]}...")
            confidence_scores.append(result['score'])
        
        avg_confidence = sum(confidence_scores) / len(confidence_scores) if confidence_scores else 0.5
        
        return {
            'response': '\\n\\n---\\n\\n'.join(response_parts),
            'type': 'general',
            'confidence': avg_confidence,
            'sources': [{'title': r['entry'].title, 'score': r['score']} for r in knowledge_results[:3]]
        }
    
    def _extract_symptoms(self, query: str) -> List[str]:
        """Extract symptoms from user query"""
        # Simple symptom extraction - can be improved with NLP
        symptom_indicators = [
            'ƒëau', 'nh·ª©c', 's·ªët', 'ho', 'kh√≥ th·ªü', 'ch√≥ng m·∫∑t', 'bu·ªìn n√¥n',
            'm·ªát m·ªèi', 'y·∫øu', 'run', 't√™', 'ng·ª©a', 's∆∞ng', 'ph√π'
        ]
        
        query_lower = query.lower()
        found_symptoms = []
        
        for indicator in symptom_indicators:
            if indicator in query_lower:
                # Extract context around the symptom
                index = query_lower.find(indicator)
                start = max(0, index - 10)
                end = min(len(query), index + len(indicator) + 20)
                symptom_context = query[start:end].strip()
                found_symptoms.append(symptom_context)
        
        return found_symptoms
    
    def _format_symptom_response(self, result: Dict) -> str:
        """Format symptom checker response"""
        if 'error' in result:
            return result['error']
        
        response_parts = []
        
        # Found symptoms
        if result.get('symptoms'):
            response_parts.append("**Tri·ªáu ch·ª©ng ƒë∆∞·ª£c t√¨m th·∫•y:**")
            for symptom in result['symptoms']:
                response_parts.append(f"- {symptom['matched']}: {symptom['info']['description']}")
        
        # Urgency assessment
        urgency = result.get('urgency_level', 'LOW')
        if urgency == 'HIGH' or urgency == 'EMERGENCY':
            response_parts.append("\\n‚ö†Ô∏è **M·ª©c ƒë·ªô kh·∫©n c·∫•p: CAO** - N√™n g·∫∑p b√°c sƒ© ngay")
        elif urgency == 'MEDIUM':
            response_parts.append("\\n‚ö†Ô∏è **M·ª©c ƒë·ªô kh·∫©n c·∫•p: TRUNG B√åNH** - N√™n kh√°m trong v√†i ng√†y")
        else:
            response_parts.append("\\n‚úÖ **M·ª©c ƒë·ªô kh·∫©n c·∫•p: TH·∫§P** - Theo d√µi v√† t·ª± chƒÉm s√≥c")
        
        # Related diseases
        if result.get('related_diseases'):
            response_parts.append("\\n**C√≥ th·ªÉ li√™n quan ƒë·∫øn:**")
            for disease in result['related_diseases'][:3]:
                response_parts.append(f"- {disease['name']}")
        
        # Recommendations
        if result.get('recommendations'):
            response_parts.append("\\n**Khuy·∫øn ngh·ªã:**")
            for rec in result['recommendations']:
                response_parts.append(f"- {rec}")
        
        # Disclaimer
        response_parts.append("\\n---")
        response_parts.append(result.get('disclaimer', 'Th√¥ng tin n√†y ch·ªâ mang t√≠nh tham kh·∫£o, kh√¥ng thay th·∫ø ch·∫©n ƒëo√°n y khoa.'))
        
        return '\\n'.join(response_parts)
    
    def _save_response(self, question: str, response: Dict, response_type: str):
        """Save chatbot response for learning and analytics"""
        try:
            ChatbotResponse.objects.create(
                question=question,
                response=response.get('response', ''),
                response_type=response_type.upper(),
                confidence_score=response.get('confidence', 0.5)
            )
        except Exception as e:
            logger.error(f"Error saving chatbot response: {str(e)}")
    
    def get_response_analytics(self) -> Dict[str, Any]:
        """Get analytics about chatbot responses"""
        try:
            from django.db.models import Count, Avg
            
            analytics = ChatbotResponse.objects.aggregate(
                total_responses=Count('id'),
                avg_confidence=Avg('confidence_score'),
                total_usage=Count('usage_count')
            )
            
            # Response types breakdown
            type_breakdown = list(
                ChatbotResponse.objects.values('response_type')
                .annotate(count=Count('id'))
                .order_by('-count')
            )
            
            return {
                'total_responses': analytics['total_responses'] or 0,
                'average_confidence': round(analytics['avg_confidence'] or 0, 2),
                'total_usage': analytics['total_usage'] or 0,
                'response_types': type_breakdown
            }
            
        except Exception as e:
            logger.error(f"Error getting analytics: {str(e)}")
            return {}


class KnowledgeRecommendationEngine:
    """Engine for recommending relevant knowledge"""
    
    def __init__(self):
        self.search_engine = KnowledgeSearchEngine()
    
    def get_recommendations(self, user_profile: Dict, limit: int = 5) -> List[Dict]:
        """Get personalized knowledge recommendations"""
        try:
            recommendations = []
            
            # Based on user's medical history
            if user_profile.get('medical_conditions'):
                for condition in user_profile['medical_conditions']:
                    results = self.search_engine.search_knowledge(condition, limit=2)
                    recommendations.extend(results)
            
            # Based on user's age group
            age = user_profile.get('age', 0)
            if age >= 60:
                elderly_results = self.search_engine.search_by_category('PREVENTION', 'ng∆∞·ªùi cao tu·ªïi', limit=2)
                recommendations.extend(elderly_results)
            elif age >= 40:
                midlife_results = self.search_engine.search_by_category('PREVENTION', 'trung ni√™n', limit=2)
                recommendations.extend(midlife_results)
            
            # Remove duplicates and sort by relevance
            seen = set()
            unique_recommendations = []
            for rec in recommendations:
                if rec['entry'].id not in seen:
                    seen.add(rec['entry'].id)
                    unique_recommendations.append(rec)
            
            return sorted(unique_recommendations, key=lambda x: x['score'], reverse=True)[:limit]
            
        except Exception as e:
            logger.error(f"Error getting recommendations: {str(e)}")
            return []
